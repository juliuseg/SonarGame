// SDFBrickCS.compute
#pragma kernel BuildSDF

// One group handles one brick. Max 8^3 voxels.
#define MAX_SIZE 8
#define INF 1e20

// Thread group dimensions. Do not change without updating MAX_SIZE logic.
[numthreads(MAX_SIZE, MAX_SIZE, MAX_SIZE)]
void BuildSDF(uint3 tid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 ltid : SV_GroupThreadID);

cbuffer Params
{
    float3 _Origin;            // world origin of brick (min corner)
    float  _VoxelSize;         // meters
    int    _Size;              // <= MAX_SIZE
    float  _IsoLevel;
    float  _DisplacementStrength;
};

// Required noise funcs. You said you already have these in your project.
// Provide them via includes or paste implementations here.
float SampleWorleyCaves(float3 p);
float SampleFractalNoise(float3 p);

float SampleDensity(float3 p)
{
    float worley = SampleWorleyCaves(p);
    float displacement = SampleFractalNoise(p) * _DisplacementStrength;
    return worley + displacement;
}

RWStructuredBuffer<float> OutSDF;     // length = _Size^3
RWStructuredBuffer<uint>  OutOcc;     // 0/1, length = _Size^3

// Shared working buffers for a single brick.
groupshared float gsD2[MAX_SIZE * MAX_SIZE * MAX_SIZE]; // squared voxel distances
groupshared uint  gsOcc[MAX_SIZE * MAX_SIZE * MAX_SIZE];

static uint Idx(uint x, uint y, uint z, uint S) { return x + y*S + z*S*S; }

// 1D exact EDT (Felzenszwalb & Huttenlocher) on arrays of length <= MAX_SIZE.
// Local arrays are per-thread, not shared.
void EDT1D(in float f[MAX_SIZE], int n, out float d[MAX_SIZE])
{
    int v[MAX_SIZE];
    float z[MAX_SIZE + 1];

    int k = 0;
    v[0] = 0;
    z[0] = -INF;
    z[1] = +INF;

    [unroll]
    for (int q = 1; q < n; q++)
    {
        float s;
        int p;
        while (true)
        {
            p = v[k];
            s = ((f[q] + q * q) - (f[p] + p * p)) / (2.0 * (q - p));
            if (s > z[k]) break;
            k--;
            if (k < 0) { k = 0; v[0] = q; z[0] = -INF; z[1] = +INF; s = -INF; break; }
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
    }

    int kk = 0;
    [unroll]
    for (int q = 0; q < n; q++)
    {
        while (z[kk + 1] < q) kk++;
        int p = v[kk];
        float diff = q - p;
        d[q] = diff * diff + f[p];
    }
}

[numthreads(MAX_SIZE, MAX_SIZE, MAX_SIZE)]
void BuildSDF(uint3 tid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 ltid : SV_GroupThreadID)
{
    const uint S = (uint)_Size;
    if (ltid.x >= S || ltid.y >= S || ltid.z >= S) return;

    uint i = Idx(ltid.x, ltid.y, ltid.z, S);

    // 1) Occupancy at voxel centers
    float3 p = _Origin + (float3(ltid) + 0.5).xxx * _VoxelSize; // componentwise scale
    p.y = _Origin.y + (ltid.y + 0.5) * _VoxelSize;
    p.z = _Origin.z + (ltid.z + 0.5) * _VoxelSize;

    uint occ = SampleDensity(p) > _IsoLevel ? 1u : 0u;
    gsOcc[i] = occ;

    GroupMemoryBarrierWithGroupSync();

    // 2) Surface mask to seed EDT
    bool isSurface = false;
    if (ltid.x > 0)         isSurface |= (gsOcc[Idx(ltid.x - 1, ltid.y, ltid.z, S)] != occ);
    if (ltid.x + 1 < S)     isSurface |= (gsOcc[Idx(ltid.x + 1, ltid.y, ltid.z, S)] != occ);
    if (ltid.y > 0)         isSurface |= (gsOcc[Idx(ltid.x, ltid.y - 1, ltid.z, S)] != occ);
    if (ltid.y + 1 < S)     isSurface |= (gsOcc[Idx(ltid.x, ltid.y + 1, ltid.z, S)] != occ);
    if (ltid.z > 0)         isSurface |= (gsOcc[Idx(ltid.x, ltid.y, ltid.z - 1, S)] != occ);
    if (ltid.z + 1 < S)     isSurface |= (gsOcc[Idx(ltid.x, ltid.y, ltid.z + 1, S)] != occ);

    gsD2[i] = isSurface ? 0.0 : INF;

    GroupMemoryBarrierWithGroupSync();

    // 3) 3D exact EDT as three sets of independent 1D transforms.
    // X-pass: one thread per (y,z) line where ltid.x==0.
    if (ltid.x == 0)
    {
        float f[MAX_SIZE];
        float d[MAX_SIZE];
        [unroll] for (uint x = 0; x < S; x++) f[x] = gsD2[Idx(x, ltid.y, ltid.z, S)];
        EDT1D(f, S, d);
        [unroll] for (uint x = 0; x < S; x++) gsD2[Idx(x, ltid.y, ltid.z, S)] = d[x];
    }
    GroupMemoryBarrierWithGroupSync();

    // Y-pass: one thread per (x,z) column where ltid.y==0.
    if (ltid.y == 0)
    {
        float f[MAX_SIZE];
        float d[MAX_SIZE];
        [unroll] for (uint y = 0; y < S; y++) f[y] = gsD2[Idx(ltid.x, y, ltid.z, S)];
        EDT1D(f, S, d);
        [unroll] for (uint y = 0; y < S; y++) gsD2[Idx(ltid.x, y, ltid.z, S)] = d[y];
    }
    GroupMemoryBarrierWithGroupSync();

    // Z-pass: one thread per (x,y) column where ltid.z==0.
    if (ltid.z == 0)
    {
        float f[MAX_SIZE];
        float d[MAX_SIZE];
        [unroll] for (uint z = 0; z < S; z++) f[z] = gsD2[Idx(ltid.x, ltid.y, z, S)];
        EDT1D(f, S, d);
        [unroll] for (uint z = 0; z < S; z++) gsD2[Idx(ltid.x, ltid.y, z, S)] = d[z];
    }
    GroupMemoryBarrierWithGroupSync();

    // 4) Signed meters. Inside wall = negative.
    float unsignedMeters = sqrt(gsD2[i]) * _VoxelSize;
    float sign = gsOcc[i] != 0u ? -1.0 : 1.0;
    float sdf = sign * unsignedMeters;

    // Write to structured buffers
    OutSDF[i] = sdf;
    OutOcc[i] = gsOcc[i];
}
