#pragma kernel Main
#include "Includes/MarchTables.compute"
#include "Includes/Noise.compute"
#include "Includes/Worley.hlsl"

struct MCTriangle { 
    float3 positionWS0; 
    float3 positionWS1; 
    float3 positionWS2; 
};

struct Candidate {
    float3 pos;
    float3 n;
};
static const int3 cornerOffsets[8] = {
    int3(0,0,0), // 0
    int3(1,0,0), // 1
    int3(1,1,0), // 2
    int3(0,1,0), // 3
    int3(0,0,1), // 4
    int3(1,0,1), // 5
    int3(1,1,1), // 6
    int3(0,1,1)  // 7
};




float4x4 _Transform;
float _IsoLevel;
uint3 _ChunkDims;
AppendStructuredBuffer<MCTriangle> _GeneratedTriangles;
float3 _NoiseOffset;
float3 _NoiseFrequency;  // higher = denser features
RWStructuredBuffer<uint> _MinMax; // [0]=min, [1]=max
float _DisplacementStrength;
float _DisplacementScale;
int   _Octaves;
float _Lacunarity;
float _Persistence;

float3 _Up;
float _CosUp;
float _CosDown;
float _CosSide;
uint _ThresholdUINT;

AppendStructuredBuffer<Candidate> _CandidatesDown;
AppendStructuredBuffer<Candidate> _CandidatesSide;
AppendStructuredBuffer<Candidate> _CandidatesUp;


// simple PCG hash
uint pcg_hash(uint v)
{
    v ^= v >> 16;
    v *= 0x7feb352d;
    v ^= v >> 15;
    v *= 0x846ca68b;
    v ^= v >> 16;
    return v;
}

void AppendTriangle(float3 pos, float3 pos1, float3 pos2, uint triSeed)
{
    float3 c = (pos + pos1 + pos2) * (1.0/3.0);

    // record triangle in triangle buffer (if still needed)
    MCTriangle t;
    t.positionWS0 = pos;
    t.positionWS1 = pos1;
    t.positionWS2 = pos2;
    _GeneratedTriangles.Append(t);

    // Calculate area of triangle
    float3 ab = pos1 - pos;
    float3 ac = pos2 - pos;
    float3 n = normalize(cross(ab, ac));

    Candidate cand;
    cand.pos = c;
    cand.n   = n;

    if (dot(n, _Up) < -_CosDown)
    {
        _CandidatesDown.Append(cand);
    } 
    else if (dot(n, _Up) > _CosUp)
    {
        _CandidatesUp.Append(cand);
    } 
    else 
    {
        _CandidatesSide.Append(cand);
    } 

 
}


float3 TransformPoint(float3 p) {
    return mul(_Transform, float4(p, 1)).xyz;
}

float SampleFractalNoise(float3 p)
{
    float value = 0;
    float amplitude = 1.0;
    float frequency = 1.0;

    for (int i = 0; i < _Octaves; i++)
    {
        value += snoise(p * frequency / _DisplacementScale) * amplitude;
        frequency *= _Lacunarity;
        amplitude *= _Persistence;
    }

    return value;
}


float SampleSimplexNoise(float3 p) {
    // apply frequency and offset
    float3 q = p * _NoiseFrequency + _NoiseOffset;

    return snoise(q);
}

float SampleDensity(float3 p)
{
    float worley = SampleWorleyCaves(p);
    float displacement = SampleFractalNoise(p) * _DisplacementStrength;
    return worley + displacement;
}


[numthreads(8,8,8)]
void Main(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkDims.x || id.y >= _ChunkDims.y || id.z >= _ChunkDims.z) return;

    float  cornerValues[8];
    float3 cornerPos[8];

    int3 cell = int3(id);
    [unroll] for (int i = 0; i < 8; i++) {
        float3 p = (float3)(cell + cornerOffsets[i]);
        p = TransformPoint(p);
        float v = SampleDensity(p);
        cornerPos[i] = p;
        cornerValues[i] = v;

        InterlockedMin(_MinMax[0], asuint(v));
        InterlockedMax(_MinMax[1], asuint(v));
    }

    int cubeIndex = 0;
    [unroll] for (int i = 0; i < 8; i++) {
        if (cornerValues[i] < _IsoLevel) cubeIndex |= (1 << i);
    }

    int edgeMask = edges[cubeIndex];
    if (edgeMask == 0) return;

    float3 edgeVerts[12];
    [unroll] for (int e = 0; e < 12; e++) {
        if (edgeMask & (1 << e)) {
            int c0 = cornerIndexAFromEdge[e];
            int c1 = cornerIndexBFromEdge[e];
            float v0 = cornerValues[c0];
            float v1 = cornerValues[c1];
            float denom = v1 - v0;
            float t = (abs(denom) > 1e-6) ? (_IsoLevel - v0) / denom : 0.5;
            t = saturate(t);
            edgeVerts[e] = lerp(cornerPos[c0], cornerPos[c1], t);
        }
    }

    for (int k = 0; triangulation[cubeIndex][k] != -1; k += 3) {
        int e0 = triangulation[cubeIndex][k];
        int e1 = triangulation[cubeIndex][k+1];
        int e2 = triangulation[cubeIndex][k+2];
        float3 v0 = edgeVerts[e0];
        float3 v1 = edgeVerts[e1];
        float3 v2 = edgeVerts[e2];

        // derive a stable per-triangle seed (e.g. from dispatch ID and loop index)
        uint triSeed = (id.x*73856093u) ^ (id.y*19349663u) ^ (id.z*83492791u) ^ (uint)k;

        AppendTriangle(v0, v1, v2, triSeed);
    }
}
