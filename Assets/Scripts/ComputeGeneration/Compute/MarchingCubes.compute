#pragma kernel Main
#include "Includes/MarchTables.compute"
#include "Includes/Noise.compute"

struct MCVertex { 
    float3 positionOS; 
};

static const int3 cornerOffsets[8] = {
    int3(0,0,0), // 0
    int3(1,0,0), // 1
    int3(1,1,0), // 2
    int3(0,1,0), // 3
    int3(0,0,1), // 4
    int3(1,0,1), // 5
    int3(1,1,1), // 6
    int3(0,1,1)  // 7
};


float4x4 _Transform;
float _IsoLevel;
uint3 _ChunkDims;
AppendStructuredBuffer<MCVertex> _GeneratedVertices;

void AppendVertex(float3 pos)
{
    MCVertex v; 
    v.positionOS = pos; 
    _GeneratedVertices.Append(v);
}

float sampleNoise(float3 pOS) {
    float3 p = mul(_Transform, float4(pOS,1)).xyz;
    return snoise(p);
}

[numthreads(8,8,8)]
void Main(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkDims.x || id.y >= _ChunkDims.y || id.z >= _ChunkDims.z) return;

    float  cornerValues[8];
    float3 cornerPos[8];

    int3 cell = int3(id);
    [unroll] for (int i = 0; i < 8; i++) {
        cornerPos[i]   = (float3)(cell + cornerOffsets[i]);
        cornerValues[i] = sampleNoise(cornerPos[i]);
    }

    int cubeIndex = 0;
    [unroll] for (int i = 0; i < 8; i++) {
        if (cornerValues[i] < _IsoLevel) cubeIndex |= (1 << i);
    }

    int edgeMask = edges[cubeIndex];
    if (edgeMask == 0) return;

    float3 edgeVerts[12];
    [unroll] for (int e = 0; e < 12; e++) {
        if (edgeMask & (1 << e)) {
            int c0 = cornerIndexAFromEdge[e];
            int c1 = cornerIndexBFromEdge[e];
            float v0 = cornerValues[c0];
            float v1 = cornerValues[c1];
            float denom = v1 - v0;
            float t = (abs(denom) > 1e-6) ? (_IsoLevel - v0) / denom : 0.5;
            t = saturate(t);
            edgeVerts[e] = lerp(cornerPos[c0], cornerPos[c1], t);
        }
    }

    for (int k = 0; triangulation[cubeIndex][k] != -1; k += 3) {
        int e0 = triangulation[cubeIndex][k];
        int e1 = triangulation[cubeIndex][k+1];
        int e2 = triangulation[cubeIndex][k+2];
        float3 v0 = edgeVerts[e0];
        float3 v1 = edgeVerts[e1];
        float3 v2 = edgeVerts[e2];
        AppendVertex(v0);
        AppendVertex(v1);
        AppendVertex(v2);
    }
}
