#pragma kernel TerrainGeneration
#include "Includes/MarchTables.compute"
#include "Includes/SampleDensity.hlsl"

struct MCTriangle
{
    float3 positionWS0;
    float3 positionWS1;
    float3 positionWS2;
    float3 colorWS;
};

// header holds total triangle count and biome mask
// only element [0] is used
RWStructuredBuffer<uint2> _Header; // { triCount, biomeMask }
AppendStructuredBuffer<MCTriangle> _GeneratedTriangles;

float4x4 _Transform;
float _IsoLevel;
uint3 _ChunkDims;

static const int3 cornerOffsets[8] = {
    int3(0,0,0), int3(1,0,0), int3(1,1,0), int3(0,1,0),
    int3(0,0,1), int3(1,0,1), int3(1,1,1), int3(0,1,1)
};

float3 TransformPoint(float3 p)
{
    return mul(_Transform, float4(p, 1)).xyz;
}

void AppendTriangle(float3 pos, float3 pos1, float3 pos2, bool terrainEditAll)
{
    float3 c = (pos + pos1 + pos2) * (1.0 / 3.0);

    MCTriangle t;
    t.positionWS0 = pos;
    t.positionWS1 = pos1;
    t.positionWS2 = pos2;

    if (terrainEditAll)
    {
        t.colorWS = float3(100, 0, 0);
    }
    else
    {
        t.colorWS = GetBiomeVertexColor(c);
    }

    // biome mask and triangle count
    uint biomeIndex = (uint)t.colorWS.x;
    uint bit = 1u << biomeIndex;
    InterlockedAdd(_Header[0].x, 1);     // count triangles
    InterlockedOr(_Header[0].y, bit);    // combine biome bits

    _GeneratedTriangles.Append(t);
}

// shared caches
groupshared float gDensity[9][9][9];
groupshared uint  gEditMask[9][9][9];

[numthreads(8,8,8)]
void TerrainGeneration(uint3 id : SV_DispatchThreadID,
                       uint3 gid : SV_GroupID,
                       uint3 tid : SV_GroupThreadID)
{
    bool active = (id.x < _ChunkDims.x && id.y < _ChunkDims.y && id.z < _ChunkDims.z);
    const uint3 base = gid * 8u;

    // reset header (only once)
    if (all(id == 0))
    {
        _Header[0] = uint2(0, 0);
    }
    GroupMemoryBarrierWithGroupSync();

    // Phase 1: compute corner densities
    uint lidx = tid.x + tid.y * 8u + tid.z * 64u;
    for (uint i = lidx; i < 729u; i += 512u)
    {
        uint z = i / 81u;
        uint rem = i - z * 81u;
        uint y = rem / 9u;
        uint x = rem - y * 9u;

        uint3 cornerCell = base + uint3(x, y, z);
        bool inBounds = (cornerCell.x <= _ChunkDims.x) &
                        (cornerCell.y <= _ChunkDims.y) &
                        (cornerCell.z <= _ChunkDims.z);

        float dens = 1e6;
        uint  edited = 0u;

        if (inBounds)
        {
            float3 wpos = TransformPoint((float3)cornerCell);
            bool terrainEdit = false;
            dens = SampleDensity(wpos, terrainEdit);
            edited = terrainEdit ? 1u : 0u;
        }

        gDensity[x][y][z] = dens;
        gEditMask[x][y][z] = edited;
    }

    GroupMemoryBarrierWithGroupSync();

    if (!active) return;

    float cornerValues[8];
    bool  terrainEditAll = false;

    [unroll]
    for (int i = 0; i < 8; i++)
    {
        int3 off = cornerOffsets[i];
        uint lx = tid.x + off.x;
        uint ly = tid.y + off.y;
        uint lz = tid.z + off.z;

        cornerValues[i] = gDensity[lx][ly][lz];
        terrainEditAll = terrainEditAll || (gEditMask[lx][ly][lz] != 0u);
    }

    int cubeIndex = 0;
    [unroll]
    for (int i = 0; i < 8; i++)
        cubeIndex |= (cornerValues[i] < _IsoLevel) ? (1 << i) : 0;

    int edgeMask = edges[cubeIndex];
    if (edgeMask == 0) return;

    float3 edgeVertsWS[12];
    float3 cornerPosGrid[8];

    [unroll]
    for (int i = 0; i < 8; i++)
        cornerPosGrid[i] = (float3)(base + tid + cornerOffsets[i]);

    [unroll]
    for (int e = 0; e < 12; e++)
    {
        if (edgeMask & (1 << e))
        {
            int c0 = cornerIndexAFromEdge[e];
            int c1 = cornerIndexBFromEdge[e];
            float v0 = cornerValues[c0];
            float v1 = cornerValues[c1];

            float denom = v1 - v0;
            float t = (abs(denom) > 1e-6) ? ((_IsoLevel - v0) / denom) : 0.5;
            t = saturate(t);

            float3 pGrid = lerp(cornerPosGrid[c0], cornerPosGrid[c1], t);
            edgeVertsWS[e] = TransformPoint(pGrid);
        }
    }

    for (int k = 0; triangulation[cubeIndex][k] != -1; k += 3)
    {
        int e0 = triangulation[cubeIndex][k + 0];
        int e1 = triangulation[cubeIndex][k + 1];
        int e2 = triangulation[cubeIndex][k + 2];

        float3 v0 = edgeVertsWS[e0];
        float3 v1 = edgeVertsWS[e1];
        float3 v2 = edgeVertsWS[e2];

        AppendTriangle(v0, v1, v2, terrainEditAll);
    }
}


