#pragma kernel EDT_X
#pragma kernel EDT_Y
#pragma kernel EDT_Z
#pragma target 5.0

uint3 _ChunkDims;
float _MaxDistance;
int _BinarizeInput;      // 1 only for first pass
int _UseExternalInput;   // 1 only for X pass
int _FlipDensity;        // 0 does not flip, 1 flips. Flips density so 

RWStructuredBuffer<float> EDTBuffer;     // read/write in-place
StructuredBuffer<float>   EDTInput;      // read-only, used only on X

int Index(int3 p)
{
    return p.z + p.y * _ChunkDims.z + p.x * _ChunkDims.z * _ChunkDims.y;
}

float ReadAt(int3 p)
{
    float v = (_UseExternalInput == 1) ? EDTInput[Index(p)] : EDTBuffer[Index(p)];
    float binarized = (_BinarizeInput == 1)
        ? ((_FlipDensity == 1)
            ? ((v < 0.5) ? 0.0 : _MaxDistance)
            : ((v > 0.5) ? 0.0 : _MaxDistance))
        : v;
    return binarized;
}

void EDT1D_Line(int fixedA, int fixedB, int axis)
{
    int n = (axis == 0) ? _ChunkDims.x : ((axis == 1) ? _ChunkDims.y : _ChunkDims.z);

    // NOTE: requires each axis <= 256. Increase if needed.
    float f[32], d[32];
    int   v[32];
    float zt[33];

    // load
    [loop]
    for (int i = 0; i < n; i++)
    {
        int3 p = (axis == 0) ? int3(i, fixedA, fixedB) :
                  (axis == 1) ? int3(fixedA, i, fixedB) :
                                int3(fixedA, fixedB, i);
        f[i] = ReadAt(p);
    }

    // Felzenszwalb 1D
    int k = 0; v[0] = 0; zt[0] = -_MaxDistance; zt[1] = +_MaxDistance;
    [loop]
    for (int q = 1; q < n; q++)
    {
        float s;
        do {
            int pIdx = v[k];
            s = ((f[q] + (q*q)) - (f[pIdx] + (pIdx*pIdx))) / (2.0 * (q - pIdx));
            // GUARD: do not let k go negative
            if (k > 0 && s <= zt[k]) { k--; } else { break; }
        } while (true);
        k++; v[k] = q; zt[k] = s; zt[k+1] = +_MaxDistance;
    }

    k = 0;
    [loop]
    for (int p = 0; p < n; p++)
    {
        while (zt[k+1] < p) k++;
        int pIdx = v[k];
        float dval = (float)(p - pIdx);
        d[p] = dval*dval + f[pIdx];
    }

    // store
    [loop]
    for (int j = 0; j < n; j++)
    {
        int3 p = (axis == 0) ? int3(j, fixedA, fixedB) :
                (axis == 1) ? int3(fixedA, j, fixedB) :
                            int3(fixedA, fixedB, j);

        EDTBuffer[Index(p)] = d[j];
    }

}

[numthreads(8,8,1)]
void EDT_X(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkDims.y || id.y >= _ChunkDims.z) return; // x=y-lines, y=z-lines
    EDT1D_Line(id.x, id.y, 0);
}

[numthreads(8,8,1)]
void EDT_Y(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkDims.x || id.y >= _ChunkDims.z) return; // x=x-lines, y=z-lines
    EDT1D_Line(id.x, id.y, 1);
}

[numthreads(8,8,1)]
void EDT_Z(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ChunkDims.x || id.y >= _ChunkDims.y) return; // x=x-lines, y=y-lines
    EDT1D_Line(id.x, id.y, 2);
}

// ------------------------------------------------------------


#pragma kernel CopyBuffer
RWStructuredBuffer<float> BufferDst;
StructuredBuffer<float>   BufferSrc;
uint _Total;

[numthreads(64,1,1)]
void CopyBuffer(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _Total) return;
    BufferDst[i] = BufferSrc[i];
}


// ------------------------------------------------------------

#pragma kernel ComputeSDFWithHalos
StructuredBuffer<float>   EDTIn;   // inside distances (with halo padding)
StructuredBuffer<float>   EDTOut;  // outside distances (with halo padding)
RWStructuredBuffer<float> SDFHalos; // output, no halos

uint _Halo;

int Index3D(int3 p, int3 dims)
{
    return p.z + p.y * dims.z + p.x * dims.y * dims.z;
}

[numthreads(64,1,1)]
void ComputeSDFWithHalos(uint3 id : SV_DispatchThreadID)
{ 
    uint flat = id.x;
    uint total = _ChunkDims.x * _ChunkDims.y * _ChunkDims.z;
    if (flat >= total) return;

    // decode flat index into local coords (within chunk)
    int3 p;
    p.x = flat / (_ChunkDims.y * _ChunkDims.z);
    int rem = flat % (_ChunkDims.y * _ChunkDims.z);
    p.y = rem / _ChunkDims.z;
    p.z = rem % _ChunkDims.z;

    // map to halo-padded coords
    int3 pHalo = p + int3(_Halo, _Halo, _Halo);
    int3 dimsHalo = _ChunkDims + int3(_Halo * 2, _Halo * 2, _Halo * 2);

    int idxHalo = Index3D(pHalo, dimsHalo);

    float din  = EDTIn[idxHalo];   // inside squared distance
    float dout = EDTOut[idxHalo];  // outside squared distance

    // true signed distance (negative inside)
    float sdf = sqrt(dout) - sqrt(din);

    SDFHalos[flat] = sdf;
}
